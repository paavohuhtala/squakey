WHITESPACE = _{ " " | "\t" | silent_newline }
COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

silent_newline = _{ "\r\n" | "\n" }
newline = ${ ("\r\n" | "\n") }

type_entity = { "entity" }
type_float = { "float" }
type_vector = { "vector" }
type_string = { "string" }
type_void = { "void" }

builtin_type = { type_entity | type_float | type_vector | type_string | type_void }

identifier_1st = _{ ('a' .. 'z') | ('A' .. 'Z') | "_" }
identifier_rest = _{ '0' .. '9' | identifier_1st }
identifier = @{ identifier_1st ~ identifier_rest* }

// https://pest.rs/book/examples/json.html
string_literal = ${ "\"" ~ string_content ~ "\"" }
string_content = @{ string_char* }
string_char = {
    !("\"" | "\\") ~ ANY
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}
number_literal = @{
    "-"?
    ~ ("0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*)
    ~ ("." ~ ASCII_DIGIT*)?
// TODO: Looks like FTEQCC doesn't support scientific notation?
//    ~ (^"e" ~ ("+" | "-")? ~ ASCII_DIGIT+)?
}

vector_literal = { "'" ~ number_literal ~ number_literal ~ number_literal ~ "'" }

// https://github.com/segeljakt/ast/blob/master/examples/calc.pest

expression = { field_access | call | primary ~ (infix ~ primary)*  }

infix = _{ add | sub | mul | div | and | bitwise_and | or | bitwise_or | bitwise_xor }
add = { "+" }
sub = { "-" }
mul = { "*" }
div = { "/" }
and = { "&&" }
or = { "||" }
bitwise_and = { "&" }
bitwise_or = { "|" }
bitwise_xor = { "^" }
equals = { "==" }
not_equals = { "!=" }

prefix = _{ neg | not }
neg = { "-" }
not = { "!" }

prefixed = { prefix ~ primary }

call_arguments = { "(" ~ expression ~ ( "," ~ expression )* ~ ")" }
call = { primary ~ ( "(" ~ ")" | call_arguments ) }
field_access = { primary ~ "." ~ identifier }

primary = _{
  string_literal |
  number_literal |
  vector_literal |
  identifier |
  prefixed |
  "(" ~ expression ~ ")"
}

argument = { builtin_type ~ identifier }
argument_list = {("(" ~ ")") | "(" ~ argument ~ ( "," ~ argument )* ~ ")" }
function_type = { builtin_type ~ argument_list }
any_type = _{ function_type | builtin_type }

end_of_declaration = @{ ";" ~ newline? }
field_declaration = { "." ~ any_type ~ identifier ~ end_of_declaration }

block = { "{" ~ statement* ~ "}" }
initializer = { "=" ~ ( block | expression ) }
binding = { any_type ~ identifier ~ initializer? ~ end_of_declaration }

assignment = { expression ~ "=" ~ expression ~ end_of_declaration }

expression_statement = { expression ~ end_of_declaration}
statement = { declaration | assignment | expression_statement }

declaration = !{ WHITESPACE* ~ field_declaration | binding }

program = _{ (newline | declaration)* }
main = ${ SOI ~ program ~ EOI }
