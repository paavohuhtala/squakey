
// Inspired by:
// - The Pest book
//  https://pest.rs/book/examples/json.html
// - This Peg grammar for Java 1.7
//  https://github.com/pointlander/peg/blob/0d618c19cd3c991caccb57451d418b16a6ea2595/grammars/java/java_1_7.peg

WHITESPACE = _{ " " | "\t" | silent_newline }
COMMENT = { ("/*" ~ (!"*/" ~ ANY)* ~ "*/") | ("//" ~ (!newline ~ ANY)* ~ silent_newline) }

space = _{ " " | "\t" }
silent_newline = _{ "\r\n" | "\n" }
newline = ${ ("\r\n" | "\n") }

type_entity = { "entity" }
type_float = { "float" }
type_vector = { "vector" }
type_string = { "string" }
type_void = { "void" }

builtin_type = { type_entity | type_float | type_vector | type_string | type_void }

identifier_1st = _{ ('a' .. 'z') | ('A' .. 'Z') | "_" }
identifier_rest = _{ '0' .. '9' | identifier_1st }
identifier = @{ identifier_1st ~ identifier_rest* }

string_literal = ${ "\"" ~ string_content ~ "\"" }
string_content = @{ string_char* }
string_char = {
    !("\"" | "\\") ~ ANY
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}
integer_literal = @{ "0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT* }
number_literal = @{
    "-"?
    ~ integer_literal
    ~ ("." ~ ASCII_DIGIT*)?
// TODO: Looks like FTEQCC doesn't support scientific notation?
//    ~ (^"e" ~ ("+" | "-")? ~ ASCII_DIGIT+)?
}

vector_literal = { "'" ~ number_literal ~ number_literal ~ number_literal ~ "'" }

// https://github.com/segeljakt/ast/blob/master/examples/calc.pest

infix = _{ add | sub | mul | div | and | bitwise_and | or | bitwise_or | bitwise_xor }
add = { "+" }
sub = { "-" }
mul = { "*" }
div = { "/" }
and = { "&&" }
or = { "||" }
bitwise_and = { "&" }
bitwise_or = { "|" }
bitwise_xor = { "^" }
equals = { "==" }
not_equals = { "!=" }

prefix = _{ neg | not }
neg = { "-" }
not = { "!" }

prefixed = { prefix ~ unary_expression }

expression = { unary_expression ~ (infix ~ unary_expression)* }

call_arguments = { "(" ~ (expression ~ ( "," ~ expression )*)? ~ ")" }
identifier_call = { identifier ~ call_arguments } 

unary_expression = { primary ~ selector* }
selector = { "." ~ identifier ~ call_arguments? }

primary = _{
  "(" ~ expression ~ ")" |
  string_literal |
  number_literal |
  vector_literal |
  identifier_call |
  identifier |
  prefixed
}

argument = { any_type ~ identifier }
argument_list = {("(" ~ ")") | "(" ~ argument ~ ( "," ~ argument )* ~ ")" }
function_type = { builtin_type ~ argument_list }
field_reference_type = { "." ~ any_type }
pointer_asterisk = { "*" }
any_type = { (function_type | field_reference_type | builtin_type) ~ pointer_asterisk? }

end_of_declaration = @{ ";"? ~ newline? }
end_of_statement = @{ ";" ~ newline? }

field_declaration = !{ "." ~ any_type ~ identifier ~ ( "," ~ identifier )* ~ end_of_declaration }

block = ${ "{" ~ silent_newline? ~ (newline | statement)* ~ WHITESPACE* ~ "}" }
builtin_reference = ${ "#" ~ integer_literal }
initializer = { "=" ~ ( builtin_reference | block | expression ) }

binding_const = { "const" }
binding_var = { "var" }
binding_nosave = { "nosave" }
binding_modifier = _{ binding_const | binding_var | binding_nosave }
binding_modifiers = { binding_modifier* }

binding = !{
  "local"? ~
  binding_modifiers ~
  any_type ~
  identifier ~
  initializer? ~
  ("," ~ identifier ~ initializer?)* ~
  end_of_declaration
}

assignment = !{ expression ~ "=" ~ expression ~ end_of_statement }

comment_content = ${ (!newline ~ ANY)* }
line_comment = ${ "//" ~ comment_content ~ silent_newline }
comment_after = ${ space* ~ "//"  ~ comment_content ~ silent_newline }

expression_statement = !{ expression ~ end_of_statement }
statement = ${ WHITESPACE* ~ (line_comment | declaration | assignment | expression_statement ) ~ comment_after? }

declaration = ${
  (space* ~ newline) |
  (space* ~ line_comment) |
  WHITESPACE* ~
    (
      field_declaration |
      binding
    ) ~
    (comment_after | space*)
}

program = _{ declaration* }
main = ${ SOI ~ program ~ EOI }
